## TASK 1:

Ця програма демонструє використання команди `getent passwd` та обробку її результатів у мові C для визначення звичайних користувачів, зареєстрованих у системі.

**Пояснення:**
- Програма виконує команду `getent passwd`, щоб отримати список усіх облікових записів.
- Кожен рядок результату містить інформацію про користувача у форматі: `ім'я_користувача:x:UID:GID:коментар:домашній_каталог:shell`.
- Програма розбирає кожен рядок, витягує `UID` і визначає, чи є він більшим за порогове значення (1000 або 500 — залежно від дистрибутиву).
- Виводяться всі звичайні користувачі з UID > 1000, **окрім поточного користувача**.

## Як запустити:

1. Скомпілюйте програму: `gcc -o check_users check_users.c`
2. Запустіть програму: `./check_users`

**Очікуваний результат:**

- Програма виведе ім’я поточного користувача та його UID.
- Якщо знайдено інших звичайних користувачів (UID > 1000), буде виведено їхні імена та UID.
- Якщо таких користувачів немає, буде повідомлення: `Інших звичайних користувачів не знайдено.`

## TASK 2:

Ця програма демонструє використання виклику `system()` у мові C для виконання адміністративної команди `cat /etc/shadow` через `sudo`, навіть якщо саму програму запускає звичайний користувач.

**Пояснення:**
- Файл `/etc/shadow` містить хешовані паролі користувачів і доступний лише root-користувачу.
- Програма викликає команду `sudo cat /etc/shadow` через `system()`, що дозволяє звернутися до захищеного ресурсу.
- Для успішного виконання програми користувач повинен мати відповідні права в системі `sudo`:
  - або право запуску `sudo` з введенням пароля,
  - або налаштований доступ без пароля до `cat /etc/shadow`.

## Як запустити:

1. Скомпілюйте програму: `gcc -o main main.c`
2. Запустіть програму: `./main`
3. Якщо буде запит — введіть пароль адміністратора.

**Очікуваний результат:**

- Якщо доступ дозволено, буде виведено вміст файлу `/etc/shadow`.
- Якщо ні — з’явиться повідомлення про помилку доступу або відмову `sudo`.

## TASK 3:

Ця програма демонструє особливості доступу до файлів у Unix/Linux, коли файл створюється звичайним користувачем, копіюється root-користувачем до домашньої директорії користувача, після чого відбувається спроба змінити та видалити файл звичайним обліковим записом.

**Пояснення:**
- Спочатку створюється файл `/tmp/user_file.txt` від імені звичайного користувача.
- Потім за допомогою команди `sudo cp` файл копіюється до домашньої директорії користувача (наприклад, `/home/nastia/copied_by_root.txt`).
- Після копіювання root-користувач передає право власності на копію (`chown`) звичайному користувачеві.
- Звичайний користувач:
  - зможе відкрити файл на запис і змінити його;
  - зможе видалити файл, оскільки він є власником файлу та має права на директорію.

> **Якщо не змінити власника файлу (`chown`) після копіювання від імені root, звичайний користувач не зможе його змінити чи видалити.**

## Як запустити:

1. Замініть у коді `your_username` на ваш справжній логін у системі.
2. Скомпілюйте програму:
   ```bash
   gcc -o main main.c
   ```
3. Запустіть програму:
   ```bash
   ./main
   ```

>  Під час виконання програма викличе `sudo`, тому вам буде запропоновано ввести пароль адміністратора.

**Очікуваний результат:**

- Створення файлу: успішне.
- Копіювання та зміна власника: успішне (за наявності прав `sudo`).
- Запис у файл: успішний.
- Видалення файлу: успішне.

## TASK 4:

Ця програма по черзі виконує команди `whoami` та `id`, щоб вивести ім’я поточного користувача та перелік груп, до яких він належить.

**Пояснення:**
- Команда `whoami` виводить ім’я користувача, від якого запущена програма.
- Команда `id` виводить ID користувача, а також перелік груп, до яких він належить. Якщо користувач є членом кількох груп, команда виведе список таких груп.

## Як запустити:

1. Скомпілюйте програму:
   ```bash
   gcc -o main main.c
   ```
2. Запустіть програму:
   ```bash
   ./main
   ```

**Очікуваний результат:**

- Команда `whoami` виведе ім’я користувача, від якого запущена програма.
- Команда `id` виведе ID користувача та список груп, до яких він належить.

## TASK 5:

Ця програма демонструє, як звичайний користувач створює тимчасовий файл, а потім суперкористувач змінює права доступу та власника цього файлу. Програма перевіряє, чи може звичайний користувач після цього читати або записувати файл.

**Пояснення:**
- Файл `tempfile.txt` створюється звичайним користувачем.
- Користувач вручну змінює власника та права доступу на `root` та `600`, відповідно:
  - `sudo chown root tempfile.txt`
  - `sudo chmod 600 tempfile.txt`
- Програма перевіряє можливість **читання** та **запису** в цей файл після зміни прав.
- Якщо файл належить root і має права `600`, звичайний користувач **не зможе** його прочитати або змінити.

**Як запустити:**

1. Скомпілюйте програму:  
   `gcc -o main main.c`

2. Запустіть програму:  
   `./main`

3. У відповідний момент, коли програма зупиниться, відкрийте новий термінал і виконайте:  
   ```bash
   sudo chown root tempfile.txt  
   sudo chmod 600 tempfile.txt
   ```

4. Поверніться до програми та натисніть Enter, щоб вона завершила перевірку доступу.

**Очікуваний результат:**

Програма має вивести:
```
Читання: Немає доступу (Permission denied)
Запис: Немає доступу (Permission denied)
```

Це означає, що звичайний користувач не має доступу до файлу, яким володіє root із правами лише для себе.

## TASK 6:

Ця програма демонструє перевірку прав доступу до файлів у трьох різних каталогах системи: домашній каталог користувача, `/usr/bin` та `/etc`. Програма виконує команду `ls -l` у вигляді системного виклику, а також самостійно перевіряє, чи може звичайний користувач:
- читати файл,
- записувати у файл,
- виконувати файл (лише у випадку з `/usr/bin`).

**Пояснення:**
- Для кожного з 5 файлів у каталозі:
  - Виводиться власник (UID, GID)
  - Виводяться права доступу у форматі восьмеричного значення (`755`, `644` тощо)
  - Перевіряється:
    - можливість відкриття на читання
    - можливість відкриття на запис
    - можливість виконання (`X_OK`)

Програма імітує доступ звичайного користувача до файлів з різними власниками та дозволами, щоб продемонструвати обмеження на рівні ОС.

**Як запустити:**

1. Скомпілюйте програму:  
   `gcc -o access_check access_check.c`

2. Запустіть програму:  
   `./access_check`