## TASK 1:

Програма для демонстрації використання неініціалізованої змінної. Програма написана мовою C і демонструє типову помилку програмування, коли змінна використовується до її ініціалізації. Код показує приклад **неініціалізованої змінної** (`Uninitialized Variable`, UV), яка містить випадкове значення, що призводить до неконтрольованої поведінки програми, але **не викликає миттєвий крах**.

Програма оголошує змінну `x` без ініціалізації та намагається вивести її значення. Оскільки змінна не ініціалізована, її значення є випадковим (вмістом пам'яті), і програма виведе сміттєве значення, яке може змінюватися на різних системах.

**Як перевірити помилку з Valgrind:**

1. `gcc -g uninitialized.c -o uninitialized`
2. `valgrind --track-origins=yes ./uninitialized`

## TASK 2:

Програма для демонстрації зчитування за межами виділеного масиву. Написана мовою C і демонструє типову помилку програмування, коли виконується доступ до пам’яті поза межами масиву. У цьому прикладі програма звертається до елемента масиву, який не був виділений, однак це не викликає миттєвий крах, що робить помилку важкою для виявлення.

У коді оголошено масив a[3], але програма намагається прочитати a[5]. Оскільки C не перевіряє коректність індексу на рівні виконання, програма зчитує сміттєве значення з довільної області пам’яті. Це значення є невизначеним і може змінюватись на різних системах, що ускладнює відлагодження.

Як перевірити помилку з Valgrind:

1. `gcc -g out_of_bounds.c -o out_of_bounds`
2. `valgrind ./out_of_bounds`

Не на усіх системах Valgrind покаже, що відбулося зчитування за межами виділеного блоку пам’яті (Invalid read). У моєму випадку він нічого не показує, і код виконується без жодних явних чи неявних помилок і попереджень.

## TASK 3:

Програма для демонстрації неправильного використання змінної як покажчика. Програма написана мовою C і демонструє типову помилку програмування, коли звичайна змінна використовується як покажчик, хоча такою не є. Це призводить до некоректного доступу до пам’яті (undefined behavior), що може викликати зчитування сміттєвих значень або навіть аварійне завершення програми (segmentation fault), залежно від ОС та архітектури.

У програмі оголошено змінну x і їй присвоєно значення 12345. Потім відбувається спроба зчитати значення з пам’яті за цією адресою (*(int*)x), наче x — це дійсний покажчик. Це спричиняє недійсний доступ до пам’яті.

Як перевірити помилку з Valgrind:

1. `gcc -g fake_pointer.c -o fake_pointer`
2. `valgrind ./fake_pointer`

