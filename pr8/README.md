## TASK 1:

Програма демонструє, що системний виклик write() у Unix/Linux може записати менше байтів, ніж запитано, особливо при роботі з неблокуючими дескрипторами (наприклад, каналами (pipe)).

**Як запустити:**
1. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
2. Запустіть програму: `./main`

**Очікуваний результат:**

`Requested to write 1048576 bytes, actually wrote 65536 bytes`

**Пояснення:**

Канал (`pipe`) має обмежений розмір буфера (наприклад, 65536 байт = 64 KB на типових Linux-системах). При записі у неблокуючий канал, якщо вільного місця менше, ніж розмір буфера, `write()` запише тільки доступну частину даних і поверне кількість реально записаних байтів. `write()` не чекає, поки з'явиться місце, через неблокуючий режим `(O_NONBLOCK)`.

Отже, Виклик write() не гарантує, що запише весь переданий буфер за один раз. Тому завжди потрібно перевіряти повернене значення write() та при необхідності організовувати дописування в циклі.

## TASK 2:

Програма демонструє роботу системних викликів `lseek()` та `read()` у Unix/Linux, зокрема те, як зміщення покажчика файлу впливає на прочитану інформацію.

**Як запустити:**
1. Створіть файл із відповідною послідовністю байтів (`4, 5, 2, 2, 3, 3, 7, 9, 1, 5`).
2. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
3. Запустіть програму: `./main`

**Очікуваний результат:**

```
Buffer contents:
2 3 3 7
```

**Пояснення:**

Виклик `lseek(fd, 3, SEEK_SET)` переміщує файловий покажчик на третій байт файлу (рахуючи з нуля). Далі `read(fd, buffer, 4)` читає чотири послідовні байти, починаючи з цієї позиції:

- байт №3: значення `2`
- байт №4: значення `3`
- байт №5: значення `3`
- байт №6: значення `7`

Таким чином, у буфері після виконання `read()` будуть байти `2 3 3 7`.

Отже `lseek()` дозволяє точно керувати позицією читання/запису у файлі. Після зміщення покажчика читання починається саме з вказаної позиції, що важливо для роботи з файлами довільного доступу.

## TASK 3:

Програма досліджує ефективність стандартної функції `qsort()` для різних типів вхідних даних і автоматично проводить набір тестів для перевірки правильності її роботи.

**Структура програми:**
1. Функція `compare_ints()` — функція порівняння для qsort
2. Функція `is_sorted()` — перевірка, чи масив відсортований
3. Функції-генератори масивів різних типів:
    - відсортований
    - зворотний
    - випадковий
    - з однаковими елементами
4. Функція `test_qsort()` — набір тестів для перевірки правильності
5. Функція `experiment()` — замір часу для різних типів масивів, вивід результатів

**Як запустити:**

1. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
2. Запустіть програму: `./main`

**Пояснення:**

Програма створює кілька типів масивів (випадковий, відсортований, зворотний, масиви з однаковими елементами) і вимірює час, за який `qsort()` їх сортує. Також реалізовані тести на правильність сортування для кожного масиву.

`qsort()` працює повільніше на погано підготовлених даних (відсортованих або зворотних масивах). Для кращої продуктивності у практичних програмах важливо або використовувати вдосконалені алгоритми сортування, або змінювати стратегії вибору опорного елемента.
