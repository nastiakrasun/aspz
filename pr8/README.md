## TASK 1:

Програма демонструє, що системний виклик write() у Unix/Linux може записати менше байтів, ніж запитано, особливо при роботі з неблокуючими дескрипторами (наприклад, каналами (pipe)).

**Як запустити:**
1. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
2. Запустіть програму: `./main`

**Очікуваний результат:**

`Requested to write 1048576 bytes, actually wrote 65536 bytes`

**Пояснення:**

Канал (`pipe`) має обмежений розмір буфера (наприклад, 65536 байт = 64 KB на типових Linux-системах). При записі у неблокуючий канал, якщо вільного місця менше, ніж розмір буфера, `write()` запише тільки доступну частину даних і поверне кількість реально записаних байтів. `write()` не чекає, поки з'явиться місце, через неблокуючий режим `(O_NONBLOCK)`.

Отже, Виклик write() не гарантує, що запише весь переданий буфер за один раз. Тому завжди потрібно перевіряти повернене значення write() та при необхідності організовувати дописування в циклі.

## TASK 2:

Програма демонструє роботу системних викликів `lseek()` та `read()` у Unix/Linux, зокрема те, як зміщення покажчика файлу впливає на прочитану інформацію.

**Як запустити:**
1. Створіть файл із відповідною послідовністю байтів (`4, 5, 2, 2, 3, 3, 7, 9, 1, 5`).
2. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
3. Запустіть програму: `./main`

**Очікуваний результат:**

```
Buffer contents:
2 3 3 7
```

**Пояснення:**

Виклик `lseek(fd, 3, SEEK_SET)` переміщує файловий покажчик на третій байт файлу (рахуючи з нуля). Далі `read(fd, buffer, 4)` читає чотири послідовні байти, починаючи з цієї позиції:

- байт №3: значення `2`
- байт №4: значення `3`
- байт №5: значення `3`
- байт №6: значення `7`

Таким чином, у буфері після виконання `read()` будуть байти `2 3 3 7`.

Отже `lseek()` дозволяє точно керувати позицією читання/запису у файлі. Після зміщення покажчика читання починається саме з вказаної позиції, що важливо для роботи з файлами довільного доступу.

## TASK 3:

Програма досліджує ефективність стандартної функції `qsort()` для різних типів вхідних даних і автоматично проводить набір тестів для перевірки правильності її роботи.

**Структура програми:**
1. Функція `compare_ints()` — функція порівняння для qsort
2. Функція `is_sorted()` — перевірка, чи масив відсортований
3. Функції-генератори масивів різних типів:
    - відсортований
    - зворотний
    - випадковий
    - з однаковими елементами
4. Функція `test_qsort()` — набір тестів для перевірки правильності
5. Функція `experiment()` — замір часу для різних типів масивів, вивід результатів

**Як запустити:**

1. Скомпілюйте програму за допомогою gcc: `gcc main.c -o main`
2. Запустіть програму: `./main`

**Пояснення:**

Програма створює кілька типів масивів (випадковий, відсортований, зворотний, масиви з однаковими елементами) і вимірює час, за який `qsort()` їх сортує. Також реалізовані тести на правильність сортування для кожного масиву.

`qsort()` працює повільніше на погано підготовлених даних (відсортованих або зворотних масивах). Для кращої продуктивності у практичних програмах важливо або використовувати вдосконалені алгоритми сортування, або змінювати стратегії вибору опорного елемента.

# TASK 4:

Ця програма демонструє використання системного виклику `fork()` для створення нового процесу в Unix/Linux. Виклик `fork()` створює копію поточного процесу, і результат виконання залежить від того, чи є поточний процес батьківським чи дочірнім.

**Пояснення:**
- У батьківському процесі функція `fork()` повертає **PID** дочірнього процесу (позитивне число).
- У дочірньому процесі функція `fork()` повертає **0**.

Програма виводить значення, яке повертається після виклику `fork()`.

## Як запустити:

1. Скомпілюйте програму: `gcc -o fork_example fork_example.c`
2. Запустіть програму: `./fork_example`

**Очікуваний результат:**

Програма виведе два числа:

`PID дочірнього процесу` та 0

Точний порядок виведення не можна передбачити, тому що батьківський і дочірній процеси виконуються паралельно. Можливі варіанти:
- Спочатку виводиться PID дочірнього процесу, потім `0`
- Або навпаки.

## TASK 5:

Ця програма демонструє поведінку системного виклику `write()` при записі в `FIFO (Named Pipe)`, коли немає читачів, які б споживали дані. Програма досліджує два режими роботи FIFO:
1. Неблокуючий режим
2. Блокуючий режим

**Пояснення:**

- FIFO (First In, First Out) — це спеціальний файл в операційних системах Unix/Linux, який дозволяє процесам обмінюватися даними у вигляді черги.
- У неблокуючому режимі, якщо FIFO не має читачів, виклик `write()` поверне помилку, яка вказує на відсутність доступних процесів для читання даних.
- У блокуючому режимі, якщо FIFO не має читачів, виклик `write()` буде блокувати процес до тих пір, поки хоча б один процес не почне читати з FIFO.

**Як запустити:**

1. Скомпілюйте програму: `gcc -o main main.c`
2. Запустіть програму: `./main`

**Пояснення коду:**

1. **mkfifo()** — створює FIFO файл, якщо він ще не існує.
2. **open()** — відкриває FIFO для запису в одному з режимів: неблокуючий (O_NONBLOCK) або блокуючий.
3. **write()** — намагається записати дані в FIFO. У разі неблокуючого режиму може повернути помилку, якщо немає читачів.
4. **unlink()** — видаляє FIFO після завершення роботи програми.


- У випадку неблокуючого режиму, програма перевіряє повернуту помилку `EAGAIN` або `EWOULDBLOCK` і повідомляє користувача, що не вдалося записати в FIFO через відсутність читачів.
- У блокуючому режимі, програма чекатиме, поки не з'явиться процес для читання з FIFO.