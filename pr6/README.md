## TASK 1:

Це завдання демонструє, як встановити Valgrind у Docker-контейнер із GCC, скомпілювати просту програму на C і перевірити її на витоки пам’яті.

Зібрати Docker-образ:
`docker build -t valgrind-test .`

Запустити контейнер:
`docker run --rm valgrind-test`

## TASK 2:

Цей проєкт демонструє, як автоматизувати перевірку C-програм на витоки пам’яті та інші помилки за допомогою Valgrind у середовищі Docker.

**У Dockerfile:**
- Встановлюється Ubuntu 22.04
- Інсталюються gcc та valgrind
- Копіюється C-програма (main.c)
- Програма компілюється з дебаг-символами
- Запускається під Valgrind

Зібрати Docker-образ:
`docker build -t valgrind-test .`

Запустити контейнер:
`docker run --rm valgrind-test`

## TASK 3:

Скрипт для компіляції C-програми та запуску під Valgrind
Він автоматизує компіляцію та перевірку C-програми на витоки пам’яті та інші помилки за допомогою Valgrind.

Використовує важливі опції:
- --leak-check=full: повний звіт про витоки пам’яті
- --track-origins=yes: показує, звідки взялися неініціалізовані значення

**Як запустити:**

1. Додайте свій main.c у директорію проєкту

2. Дайте скрипту право на виконання:
`chmod +x run_valgrind.sh`

3. Запустіть скрипт:
`./run_valgrind.sh`

## TASK 4:

Програма "Hello, world!" без помилок від Valgrind

Це базовий приклад C-програми, яка не викликає жодних попереджень або помилок при запуску під Valgrind. Ідеально підходить для перевірки, що компілятор і Valgrind працюють правильно. Програма не містить динамічного виділення пам’яті і не виконує жодних небезпечних дій, саме тому і не вибиває жодних помилок.

**Як перевірити:**
1. `gcc -g main.c -o hello`
2. `valgrind --leak-check=full --track-origins=yes ./hello`

## TASK 5:

Програма для демонстрації доступу до неініціалізованої змінної.  
Написана мовою C і містить типову помилку: використання локальної змінної до її ініціалізації.

У прикладі оголошено змінну `int x;`, однак перед її використанням не відбувається присвоєння значення. У C змінні, що зберігаються на стеку, мають невизначене початкове значення. Виведення такої змінної може призвести до непередбачуваної поведінки програми.

**Як перевірити помилку з Valgrind:**
1. `gcc -g main.c -o main`
2. `valgrind --leak-check=full --track-origins=yes ./main`
