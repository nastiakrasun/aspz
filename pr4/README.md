## TASK 1:

Написано програму на мові C для перевірки максимального розміру пам'яті, яку можна виділити за один виклик функції malloc(3). Програма використовує максимальний розмір типу size_t, щоб спробувати виділити пам'ять і вивести результат: чи вдалося виділити пам'ять або ж функція повернула NULL, що означає помилку. Це дозволяє перевірити, чи є в системі обмеження на максимальний розмір пам'яті, який може бути виділений для одного процесу, і оцінити можливості операційної системи в роботі з великими обсягами пам'яті.

## TASK 2:

`malloc()` є функцією для виділення пам'яті, і параметр, який передається до неї, повинен бути позитивним числом або нулем. Якщо передати від'ємний аргумент, це може призвести до непередбачуваної поведінки програми, оскільки значення типу size_t завжди є беззнаковим цілим числом. Програма може використовувати неприпустимий розмір пам'яті, або система може повернути значення `NULL` для інтерпретації помилки. Розроблена програма дає можливість потестити поведінку `malloc()` з різними значеннями за формулою `num = xa * xb`.

## TASK 3:

У виконаному завданні було досліджено поведінку функції `malloc(0)` у мові C, що виділяє пам'ять для 0 байт. Було написано тестову програму, яка викликає `malloc(0)`, перевіряє, чи повертає вона `NULL` або валідний вказівник, і передає цей вказівник до функції `free()`. Програма була скомпільована і запущена з використанням ltrace, щоб відстежити системні виклики і проаналізувати поведінку програми під час виділення та звільнення пам'яті. В результаті тесту було підтверджено, що `malloc(0)` може повернути валідний вказівник або `NULL`, а звільнення такої пам'яті через `free()` працює коректно без помилок.

## TASK 4:

У виконаному завданні було проаналізовано проблему неправильного виклику функції `free(ptr)` у циклі без перевірки, чи була пам'ять успішно виділена за допомогою `malloc(n)`. А також після звільненя пам'яті не очищувалась перемінна ptr. Було написано тестову програму, що не перевіряє виділення пам'яті, а також не очищує змінну ptr. Така програма завершується помилкою. Додатково, у новому коді реалізовано правильну перевірку перед викликом `free(ptr)`, щоб уникнути непотрібних викликів `free(NULL)`. Це забезпечує більш стабільну і зрозумілу поведінку програми, зокрема при некоректному виділенні пам'яті. А також очищується зміст змінної ptr, що не викликає помилок.

## TASK 5:

Якщо realloc(3) не зможе виділити пам'ять, вона поверне NULL, а початковий вказівник залишиться дійсним (тобто, стара пам’ять не буде звільнена). Це важливо, щоб уникнути витоків пам’яті. Було написано програму, яка:
- Виділяє початковий блок пам’яті.
- Викликає realloc() із величезним розміром, який гарантовано перевищує доступну пам’ять.
- Перевіряє, чи realloc() повернув NULL.
- Якщо realloc() не зміг виділити пам’ять, звільняє початковий блок пам’яті, щоб уникнути витоків.
Цей код показує помилку realloc failed, оскільки система не може виділити таку велику пам’ять.

## TASK 6:

У цьому завданні було досліджено поведінку функції `realloc(3)` у двох особливих випадках: коли її викликають із `NULL` (що еквівалентно `malloc(size)`) та коли розмір встановлено в 0 (поведінка залежить від реалізації: може повернути `NULL` або інший вказівник). Було реалізовано тестовий випадок на C, який демонструє ці сценарії, перевіряючи, чи `realloc` повертає коректні значення та чи потрібно звільняти пам’ять після виклику.

## TASK 7:

## TASK 8: