## TASK 1:

**Опис**  
Програма використовує функцію `popen()` для запуску команди `rwho` і передає її вивід до `more`. Таким чином, ми отримуємо можливість переглядати результат роботи `rwho` посторінково, як у класичній Unix-утиліті. Це реалізовано шляхом відкриття pipe через `popen("rwho | more", "r")` і читання результату, який виводиться в консоль.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Команди `rwho` і `more` мають бути встановлені у вашій системі. `rwho` часто вимикається в системах за замовчуванням — можна замінити на `who` для тесту.

---

## TASK 2:

**Опис**  
Програма реалізує базовий аналог команди `ls -l`. Вона використовує функції `opendir()`, `readdir()` і `stat()` для виведення імен файлів у поточному каталозі разом з їхніми правами доступу, кількістю посилань, власником, групою, розміром та датою останньої модифікації. Дані форматуються подібно до `ls -l`.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Для зручності можна протестувати на каталозі з кількома різними файлами, включаючи директорії.

---

## TASK 3:

**Опис**  
Програма імітує просту версію команди `grep`. Вона приймає два аргументи командного рядка — слово для пошуку та ім’я файлу. Відкриває файл, читає його построково та виводить ті рядки, які містять задане слово. Використовується функція `strstr()` для пошуку підрядка.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Слово розпізнається як підрядок, тобто пошук чутливий до регістру.

---

## TASK 4:

**Опис**  
Реалізована спрощена версія `more`: програма читає вміст усіх переданих файлів та виводить на екран по 20 рядків за раз. Після кожної порції рядків очікує натискання клавіші для продовження. Це дозволяє зручно переглядати великі файли без прокручування.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Корисно тестувати на великих текстових файлах або кількох файлах.

---

## TASK 5:

**Опис**  
Програма рекурсивно обходить поточний каталог і всі вкладені підкаталоги, виводячи список усіх знайдених файлів та папок. Для реалізації використано рекурсивну функцію, яка викликає себе при виявленні підкаталогу.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Уникає нескінченної рекурсії, пропускаючи `.` та `..`.

---

## TASK 6:

**Опис**  
Програма виводить лише ті елементи поточного каталогу, які є підкаталогами. Результат сортується в алфавітному порядку перед виведенням. Для сортування використано `qsort()`, а для перевірки типу файла — `stat()`.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Можна створити кілька підкаталогів з різними іменами, щоб перевірити сортування.

---

## TASK 7:

**Опис**  
Програма шукає всі `.c`-файли в поточному каталозі та пропонує надати дозвіл на читання для інших користувачів. Користувач вводить відповідь (`y`/`n`) для кожного знайденого файлу. Використовується `chmod()` для зміни прав доступу.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Запускати бажано у каталозі з кількома `.c` файлами, щоб протестувати запити.

---

## TASK 8:

**Опис**  
Програма дозволяє користувачу видалити будь-який або всі файли в поточному каталозі. Для кожного файла виводиться запит на підтвердження. Видалення виконується через `remove()`.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Обережно! Програма видаляє файли — переконайтеся, що ви працюєте у тестовому каталозі.

---

## TASK 9:

**Опис**  
Програма демонструє вимірювання часу виконання деякої частини коду (наприклад, циклу) у мілісекундах. Для цього використовується функція `clock()` з бібліотеки `time.h`. Результат виводиться у вигляді кількості мілісекунд.

**Як запустити:** 
 
```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Фрагмент коду можна змінювати, щоб тестувати різний обсяг обчислень.

---

## TASK 10:

**Опис**  
Програма генерує послідовність випадкових чисел з плаваючою комою:
- від 0.0 до 1.0
- від 0.0 до введеного значення n

Для генерації використовується `rand()` з приведенням типів. `srand(time(NULL))` ініціалізує генератор випадкових чисел.

**Як запустити:** 

```bash
1. gcc -o main main.c
2. ./main
```

**Інше:**  
Зручно використовувати для розуміння діапазону та розподілу випадкових чисел у C.
