## TASK 1:

**Опис**  
Програма використовує функцію `popen()` для запуску команди `rwho` і передає її вивід до `more`. Таким чином, ми отримуємо можливість переглядати результат роботи `rwho` посторінково, як у класичній Unix-утиліті. Це реалізовано шляхом відкриття pipe через `popen("rwho | more", "r")` і читання результату, який виводиться в консоль.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. sudo ./main
```

**Інше:**  
Команди `rwho` і `more` мають бути встановлені у вашій системі. `rwho` часто вимикається в системах за замовчуванням — можна замінити на `who` для тесту.

---

## TASK 2:

**Опис**  
Програма реалізує базовий аналог команди `ls -l`. Вона використовує функції `opendir()`, `readdir()` і `stat()` для виведення імен файлів у поточному каталозі разом з їхніми правами доступу, кількістю посилань, власником, групою, розміром та датою останньої модифікації. Дані форматуються подібно до `ls -l`.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Для зручності можна протестувати на каталозі з кількома різними файлами, включаючи директорії.

---

## TASK 3:

**Опис**  
Програма імітує просту версію команди `grep`. Вона приймає два аргументи командного рядка — слово для пошуку та ім’я файлу. Відкриває файл, читає його построково та виводить ті рядки, які містять задане слово. Використовується функція `strstr()` для пошуку підрядка.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Слово розпізнається як підрядок, тобто пошук чутливий до регістру.

---

## TASK 4:

**Опис**  
Реалізована спрощена версія `more`: програма читає вміст усіх переданих файлів та виводить на екран по 20 рядків за раз. Після кожної порції рядків очікує натискання клавіші для продовження. Це дозволяє зручно переглядати великі файли без прокручування.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Корисно тестувати на великих текстових файлах або кількох файлах.

---

## TASK 5:

**Опис**  
Програма рекурсивно обходить поточний каталог і всі вкладені підкаталоги, виводячи список усіх знайдених файлів та папок. Для реалізації використано рекурсивну функцію, яка викликає себе при виявленні підкаталогу.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Уникає нескінченної рекурсії, пропускаючи `.` та `..`.

---

## TASK 6:

**Опис**  
Програма виводить лише ті елементи поточного каталогу, які є підкаталогами. Результат сортується в алфавітному порядку перед виведенням. Для сортування використано `qsort()`, а для перевірки типу файла — `stat()`.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Можна створити кілька підкаталогів з різними іменами, щоб перевірити сортування.

---

## TASK 7:

**Опис**  
Програма шукає всі `.c`-файли в поточному каталозі та пропонує надати дозвіл на читання для інших користувачів. Користувач вводить відповідь (`y`/`n`) для кожного знайденого файлу. Використовується `chmod()` для зміни прав доступу.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Запускати бажано у каталозі з кількома `.c` файлами, щоб протестувати запити.

---

## TASK 8:

**Опис**  
Програма дозволяє користувачу видалити будь-який або всі файли в поточному каталозі. Для кожного файла виводиться запит на підтвердження. Видалення виконується через `remove()`.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Обережно! Програма видаляє файли — переконайтеся, що ви працюєте у тестовому каталозі.

---

## TASK 9:

**Опис**  
Програма демонструє вимірювання часу виконання деякої частини коду (наприклад, циклу) у мілісекундах. Для цього використовується функція `clock()` з бібліотеки `time.h`. Результат виводиться у вигляді кількості мілісекунд.

**Як запустити:** 
 
```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Фрагмент коду можна змінювати, щоб тестувати різний обсяг обчислень.

---

## TASK 10:

**Опис**  
Програма генерує послідовність випадкових чисел з плаваючою комою:
- від 0.0 до 1.0
- від 0.0 до введеного значення n

Для генерації використовується `rand()` з приведенням типів. `srand(time(NULL))` ініціалізує генератор випадкових чисел.

**Як запустити:** 

```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**  
Зручно використовувати для розуміння діапазону та розподілу випадкових чисел у C.

## TASK 11:

**Опис**  
Ця програма рекурсивно обходить ієрархію директорій файлової системи, починаючи з кореня (`/`), і будує структуру директорій, доступних поточному користувачу. При цьому:
- Програма уникає циклічних посилань (наприклад, у разі жорстких посилань або спеціально створених циклів).
- Символьні посилання залишаються у виводі (наприклад, `file -> (symlink)`), але не розшифровуються і не переходяться.
- Для цього використовується функція `nftw()` із прапором `FTW_PHYS` (щоб уникнути переходу по символьних посиланнях), а також зберігається список уже відвіданих inode, щоб уникнути повторного входу у вже оброблені директорії.

**Як запустити:**

```bash
1. gcc -Wall main.c -o main
2. ./main
```

**Інше:**
- Якщо запускати програму від імені суперкористувача (`sudo`), вона може бачити більше директорій, однак цикл обробки inode все одно запобігає нескінченному проходженню.
- Код легко адаптується для виводу до файлу, фільтрації за іменами або глибиною вкладеності.

