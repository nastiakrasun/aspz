## TASK 1:

Cтворено програму мовою C, яка визначає максимальне значення time_t та виводить відповідний йому момент часу. Програму можна скомпілювати для 32-бітної та 64-бітної архітектури з використанням опції `-m32` для 32-бітного виконуваного файлу, ну і `-m64` для 64-бітної відповідно.

Я виявила проблему, пов'язану з архітектурою мого програмного забезпечення, яка не дає можливості скомпілювати файл у 32-бітному режимі.
Командою `uname -m` я визначила, що у мене `aarch64`. Це означає що відповідні бібліотеки/пакети для 32-бітної компіляції недоступні.

Але пошукавши в інтернеті, я визначила, що на 32-бітній системі time_t переповнюється 19 січня 2038 року (проблема 2038 року), тоді як на 64-бітній системі ця проблема відсутня. 

Також було досліджено сегменти виконуваного файлу за допомогою команди `readelf -l`, що дозволило проаналізувати розподіл пам’яті та структуру ELF-файлу.

---

## TASK 2:

Створено програму мовою C для аналізу змін розмірів виконуваного файлу після додавання масивів та ініціалізацій. Для цього було створено кілька варіантів програми з різними змінами:

1. **hello.c** – Базова програма без масивів, яка компілюється для аналізу початкових розмірів виконуваного файлу.
2. **hello2.c** – Додано глобальний масив з 1000 елементів. Це призводить до збільшення сегмента **BSS**, оскільки масив не ініціалізований.
3. **hello3.c** – Масив ініціалізований, що переміщає його в сегмент **DATA** і збільшує розмір цього сегмента.
4. **hello4.c** – Додано локальні масиви до функції, що дозволяє проаналізувати зміни в стеку та сегментах **BSS/DATA**.
5. **hello5.c** – Скомпільовано з прапором `-g`, що додає налагоджувальну інформацію до виконуваного файлу, збільшуючи його розмір.
6. **hello6.c** – Скомпільовано з прапором `-O3` для максимального рівня оптимізації, що дозволяє зменшити розмір виконуваного файлу.

Кожен файл компілювався окремо, і для кожного з них були використані команди `ls -l` та `size` для аналізу змін розмірів виконуваних файлів та сегментів. Це дозволило продемонструвати, як додавання масивів, ініціалізація, а також компіляція з різними оптимізаціями впливають на структуру та розміри сегментів пам'яті в ELF-файлах.

## TASK 3:

У цьому завданні було проведено аналіз розташування стека та інших сегментів пам'яті (сегмента даних, тексту та купи) за допомогою програми на мові C. Програма вивела адреси змінних, що знаходяться в різних сегментах пам'яті, зокрема локальних змінних (стек), глобальних і статичних змінних (сегмент даних), а також змінних, виділених у купі через `malloc`. Крім того, було досліджено вплив оголошення великих локальних масивів на адресу вершини стека, що дозволило зрозуміти механізми зміщення пам'яті при зміні розміру стека. Цей аналіз допоміг краще усвідомити структуру пам'яті комп'ютера та принципи управління пам'яттю під час виконання програм.

## TASK 4:

Було створено програму на C, яка виконує вкладені виклики функцій і блокується на `pause()`, що дозволяє проаналізувати її стек під час виконання. Програму скомпілювали з відладочною інформацією (`-g`), запустили та визначили її `PID`. Для аналізу стеку використовували `GDB`, так як інші інструменти були недоступні. У корені завдання є файл з командами та коментарями, щоб було легше та зручніше запускати і перевіряти. `GDB` надав розширені можливості, зокрема деталі про змінні та регістри.

## TASK 5:

Стек не може замінити лічильник команд (IP), оскільки IP автоматично змінюється для послідовного виконання коду, тоді як стек динамічно змінюється і використовується для збереження адрес повернення та даних. Використання стека для керування потоком вимагало б постійного витягування адрес вручну, що ускладнює виконання програм. Тому IP є незамінним у процесорній архітектурі.

Було нгаписано приклад програми на C, яка ілюструє, чому не можна використовувати стек замість лічильника команд (IP).

**Ідея:**
- Використовуємо функції foo(), bar(), які викликаються в main().
- Використовуємо setjmp() і longjmp() з <setjmp.h>, щоб показати, що зміна стека не змінює автоматично поточну інструкцію виконання (що робить IP).
- Без явного керування IP не вийде правильно повернутися до потрібної інструкції.

## TASK 6:

Для цього завдання була написана програма на C, яка визначає максимально можливий розмір сегмента купи (heap), виділяючи пам’ять динамічно і поступово збільшуючи її розмір, поки система не поверне помилку.

Алгоритм наступний:
- Програма поступово виділяє пам’ять блоками по 1 МБ.
- Якщо malloc() повертає NULL, значить, подальше виділення неможливе.
- Очищуємо пам’ять після кожного успішного виділення, щоб уникнути фрагментації.
- Виводимо максимальний розмір купи перед виходом.